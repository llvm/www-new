presentations:
- title: "Welcome"
  speaker: "Chris Lattner (Apple)"
  slides_url: "https://llvm.org/devmtg/2012-11/Lattner-Kickoff.pdf"
  video_url: ""
  description: ""

- title: "LLVM and Clang on the Most Powerful Supercomputer in the World"
  speaker: "Hal Finkel (Argonne National Laboratory)"
  slides_url: "https://llvm.org/devmtg/2012-11/Finkel-LLVMClangSupercomputer.pdf"
  video_url: "https://youtu.be/8_XYt8rbzRk"
  description: "The IBM Blue Gene/Q (BG/Q) now holds the first and third slots on the Top 500 list of the world's most powerful supercomputers, and LLVM with Clang now provides a high-quality autovectorizing C/C++ compiler for the BG/Q. In this talk, I'll describe the process of porting LLVM and Clang to the BG/Q, and how the LLVM IR is mapped to the BG/Q's unique vector instruction set. This process has required enhancements to all levels: From the PowerPC backend through the frontend, including the development of the basic-block autovectorizer. I will demonstrate that, for a large class of codes, LLVM with Clang produces code with superior performance compared to that produced by the vendor-supplied compilers."

- title: "The AArch64 backend: Status and plans"
  speaker: "Tim Northover (ARM)"
  slides_url: "https://llvm.org/devmtg/2012-11/Northover-AArch64.pdf"
  video_url: "https://youtu.be/rvrHmrtZz-g"
  description: "A backend for ARM's new 64-bit architecture, AArch64, will very soon be added to LLVM. I intend to discuss what we've done to make sure it is a good base for future work: correct, extensible and useful. I will talk about areas we've found easy to test and the more challenging corners. The MC Hammer suite introduced at the Euro-LLVM conference ensured the completeness and correctness of encoding information, and to a lesser extent, assembly. Difficult corners I will give more details on are the usual suspects: instruction selection, relocations and the constant island pass."

- title: "Parsing Documentation Comments in Clang"
  speaker: "Dmitri Gribenko (HPC Center at National Technical University of Ukraine - Kiev Polytechnic Institute)"
  slides_url: "https://llvm.org/devmtg/2012-11/Gribenko_CommentParsing.pdf"
  video_url: "https://youtu.be/DzRq9Dy0b9c"
  description: "The documentation written in comments is usually processed by a third-party tool while the compiler just ignores it, but the compiler could extract some extra information from it. We could use documentation from comments to enhance tools based on Clang libraries. Now Clang does additional semantic checking on documentation and emits warnings to help the programmer ensure that comments don't get stale. Code completion APIs now include documentation associated with each completion result. libclang is enhanced with an API to get the documentation attached to any declaration; this could be used to build a Clang-based Doxygen-like tool. In future, when we try to tackle automatic refactoring, we could use this framework to update names referenced in comments so that documentation stays up to date."

- title: "MemorySanitizer and ThreadSanitizer: Scalable run-time detection of uninitialized memory reads and data races with LLVM instrumentation."
  speaker: "Kostya Serebryany (Google)"
  slides_url: "https://llvm.org/devmtg/2012-11/Serebryany_TSan-MSan.pdf"
  video_url: "https://youtu.be/HDgttiIvMxA"
  description: "Following the success of AddressSanitizer (asan), a fast detector of use-after-free and buffer overflow bugs, we have developed two more bug detection tools based on similar ideas. MemorySanitizer (msan, http://code.google.com/p/memory-sanitizer/) detects uninitialized memory reads. It shares many ideas with Valgrind/Memcheck, however it is also different in two important ways: it uses compile-time instrumentation (LLVM) and 1:1 direct shadow memory mapping. Unless the entire program (including libc) is instrumented, msan requires a simple binary instrumentation component (we have an implementation based on DynamoRIO). The slowdown introduced by the tool is typically 2x-3x (compare to Valgrind's 20x). ThreadSanitizer (tsan, http://code.google.com/p/thread-sanitizer/) detects data races. The tool has been briefly mentioned at the 2011 llvm dev meeting but has matured since that time. Similarly to asan and msan, it uses compile-time instrumentation (LLVM), but 95% of the logic is contained in the run-time library. Tsan uses 1:4 direct shadow memory mapping (i.e. uses ~5x more memory). It does not have locks or atomic instructions on the fast path, which makes it scale to large and heavily threaded applications. The slowdown varies between 3x and 10x."

- title: "Verified LLVM: Formalizing the semantics of the LLVM Intermediate Representation for Verified Program Transformations"
  speaker: "Santosh Nagarakatte (University of Pennsylvania/Rutgers University)"
  slides_url: "https://llvm.org/devmtg/2012-11/Santosh-Vellvm.pdf"
  video_url: "https://youtu.be/cnwPI07R8Iw"
  description: "This talk will describe our research on building Vellvm (verified LLVM), a framework for reasoning about programs expressed in LLVM’s intermediate representation and transformations that operate on it. Vellvm provides a mechanized formal semantics of LLVM’s intermediate representation, its type system, and properties of its SSA form. The framework is built using the Coq interactive theorem prover. It includes multiple operational semantics and proves relations among them to facilitate different reasoning styles and proof techniques. To validate Vellvm’s design, we extract an interpreter from the Coq formal semantics that can execute programs from LLVM test suite and thus be compared against LLVM reference implementations. This talk will also highlight Vellvm’s practicality by demonstrating our efforts in formalizing and verifing a variant of mem2reg optimization within the LLVM compiler suite, and our previoulsy proposed SoftBoundCETS memory safety transformation operating on the LLVM IR. The talk will conclude highlighting the benefits of such formalization efforts to expose compiler bugs and the avenues such a formalizing effort can benefit from compiler developer involvement. Joint work with Jianzhou Zhao, Milo M K Martin and Steve Zdancewic at the University of Pennsylvania."

- title: "Modules"
  speaker: "Doug Gregor (Apple)"
  slides_url: "https://llvm.org/devmtg/2012-11/Gregor-Modules.pdf"
  video_url: "https://youtu.be/586c_QMXir4"
  description: "The C preprocessor has long been a source of problems for programmers and tools alike. Programmers must contend with widespread macro pollution and include-ordering problems due to ill-behaved headers. Developers habitually employ various preprocessor workarounds, such as LONG_MACRO_PREFIXES, include guards, and the occasional #undef of a library macro to mitigate these problems. Tools, on the other hand, must cope with the inherent scalability problems associated with parsing the same headers repeatedly, because each different preprocessing context could effect how a header is interpreted---even though the programmer rarely wants it. Modules seeks to solve this problem by isolating the interface of a particular library and compiling it (once) into an efficient, serialized representation that can be efficiently imported whenever that library is used, improving both the programmer's experience and the scalability of the compilation process."

- title: "Integrated Security, using LLVM for Dynamic and Static Security Tasks"
  speaker: "Jared Carlson (GoToTheBoard)"
  slides_url: "https://llvm.org/devmtg/2012-11/Carlson-FromSource.pdf"
  video_url: "https://youtu.be/9GSDwFRGuZw"
  description: "This talk will discuss how to leverage the LLVM and LLDB tools and technologies to create a flexible security infrastructure. The talk discusses incorporating both static and dynamic analysis techniques by using LLVM and LLDB components and that these can easily be integrated back into LLVM development workflow. These tools will help find exploitable bugs within the llvm development environment, illustrate their consequences and are customizable and easily shared within the community. Funded by DARPA as a Cyber Fast Track effort, we are currently incorporating LLDB and other open-source Python libraries along with re-written static analysis scripts so that the tools can be easily integrated and altered into a workflow. It is anticipated that milestone two, an alpha, will be finished in early September and then the project will wrap up in early November with a beta release. The talk will discuss how we use the tools to investigate bug severity, utilize artificial intelligence techniques to predispose fuzzing, draw conclusions, and utilize the LLVM technology quite to target various architectures if desired."

- title: "How good are Clang's diagnostics, anyway?"
  speaker: "Matt Beaumont-Gay (Google)"
  slides_url: "https://llvm.org/devmtg/2012-11/Beaumont-Gay-Diagnostics.pdf"
  video_url: "https://youtu.be/j2e6VkFU_QE"
  description: "Most of the feedback we get on Clang’s diagnostics is in the form of bug reports (or occasionally people saying nice things about us on the Internet). As developers, we also eat our own proverbial dogfood, and we can assess new diagnostics against various open-source and proprietary codebases, but we don’t have a large-scale view into the diagnostics experience for code that’s under development. The build system for Google’s shared codebase keeps all of the output for all of the builds that we do. So, like a good Google engineer, I wrote a MapReduce, using the build result store as input. We now have a daily batch job that crunches through all of the compiler stderr from the last day, parses out detailed, structured information about the diagnostics that Clang produced, and writes the information into a database for later analysis. I’ll discuss the design of the MapReduce, touch on the various pieces of infrastructure that make it work, and present results on the diagnostics seen by Google engineers in their day-to-day work."

- title: "Alias Analysis in LLVM"
  speaker: "Dan Gohman (Google)"
  slides_url: "https://llvm.org/devmtg/2012-11/Gohman-AliasAnalysis.pdf"
  video_url: "https://youtu.be/gxt-uCu7Sxo"
  description: ""

- title: "Shevlin Park: A C++ AMP implementation in Clang/LLVM using OpenCL"
  speaker: "Dillon Sharlet (Intel)"
  slides_url: "https://llvm.org/devmtg/2012-11/Sharlet-ShevlinPark.pdf"
  video_url: "https://youtu.be/W2Fn7ERMJJE"
  description: "We describe 'Shevlin Park', a prototype implementation of Microsoft's C++ AMP built on Clang, LLVM, and OpenCL. We fully describe Shevlin Park’s implementation including how CLANG/LLVM can be augmented to easily accommodate C++AMP programming constructs, how C++AMP computation can be expressed as OpenCL compute kernels, and finally how the C++AMP runtime library can be easily implemented on an OpenCL runtime. Using several benchmarks, we evaluate Shevlin Park’s performance, Microsoft’s DirectX based C++AMP, and also conventional OpenCL."

- title: "Generating Hardware Description with the Target-Independent Code Generator"
  speaker: "Hongbin Zheng (Sun Yat-sen University)"
  slides_url: "https://llvm.org/devmtg/2012-11/Hongbin-Generating.pdf"
  video_url: "https://youtu.be/jvyh9xKkwKg"
  description: "Though there exist several projects generating hardware description from LLVM IR (i.e. High-level Synthesis, HLS), they are all working on the LLVM IR layer. However, the LLVM IR layer is not the best layer to perform HLS. In this talk, I am going to introduce our open source HLS framework, named Shang. Our HLS framework mainly implements its transformations and analyses in the Target-Independent Code Generator, with the HLS-specific TargetMachine, named VTargetMachine."

- title: "Zero-Cost Abstractions and Future Directions for Modern Optimizing Compilers"
  speaker: "Chandler Carruth (Google)"
  slides_url: "https://llvm.org/devmtg/2012-11/Carruth-OptimizingAbstractions.pdf"
  video_url: "https://youtu.be/qe-TT3r_ke4"
  description: "Today, Clang is a fantastic C++ optimizing compiler. It leverages all of the compiler infrastructure built as part of the LLVM project and produces binaries which have excellent performance. As compiler writers, we have done our jobs very well. So what’s next? Where is the next big opportunity for optimizing compilers, especially in the context of modern C++ code? As C++ becomes more popular, and the C++ code bases of the world become larger and more modern, we are faced with some interesting optimization challenges. C++ is popular today due to its excellent performance, but too often certain aspects of this performance rely on hand-tuned code, despite the often elusive promise of C++ providing zero-cost abstractions to programmers. In practice, the abstractions of modern C++ are not in fact zero-cost. This creates a serious danger, as the design of C++, the standard library, and many user libraries, all rely upon the abstractions they introduce having zero cost to allow layering and composing them without a combinatorial explosion of overhead. We are approaching a world where the overheads and costs our compilers fail to remove from abstractions will be magnified into the reality of Wirth’s Law: our software is getting slower more rapidly than hardware becomes faster. How do we reverse this trend? We must begin to focus optimizations on decomposing the abstractions formed in modern languages. It is these abstractions, the things which programmers naively expect to be free, which lead to the most surprising and difficult to correct performance problems. These are what must be compiled optimally to allow both idiomatic and common programming patterns to remain efficient and to achieve system wide performance improvements in a world of flat profiles. In this talk, I will walk through what some of these abstractions end up looking like in modern C++ code, explain several ways in which LLVM optimizes away these abstractions, and propose several new optimizations to further address these problems."

- title: "Building a Checker in 24 hours"
  speaker: "Anna Zaks (Apple), Jordan Rose (Apple)"
  slides_url: "https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf"
  video_url: "https://youtu.be/kdxlsP5QVPw"
  description: "Clang Static Analyzer (http://clang-analyzer.llvm.org/) is a bug finding tool based on path sensitive symbolic execution of user code. We are going to introduce basic concepts behind the analyzer and describe what it takes to write a new check."
